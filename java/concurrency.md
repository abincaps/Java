
# 并发

## 多线程

- 多线程是指实现多个线程并发执行的技术，多线程可以使计算机同一时间执行多个线程

## 线程和进程

- 进程是指内存运行的一个应用程序， 是系统运行程序的基本单位，是程序的一次执行过程
- 线程是进程中的一个执行单元，负责当前进程中的任务执行，一个进程可以产生多个线程
- 每个进程都有独立的内存空间
- 线程之间的堆空间和方法区共享，栈空间和程序计数器是独立的

## 并发和并行

- 并发（concurrency） 指的是同一时间段， 多个任务都在执行， 单位时间内不一定是同时执行
- 并行（parallel）指的是单位时间内，多个任务一定是同时执行，并行上限取决于 CPU 核心数

## 线程上下文切换

- 一个 CPU 同一时刻只能被一个线程使用
- 为了提升效率 CPU 采用时间片算法将 CPU 时间片轮流分配给多个线程
- 在分配的时间片内线程如果没有执行完毕，则需要挂起，把 CPU 让给其他线程
- 为了解决，线程下次运行时， 怎么知道上次运行到哪里的问题
- CPU切换线程，会把当前线程的执行位置记录下来，用于下次执行时找到位置
- 线程执行位置的记录和加载过程就是上下文切换

## 上下文切换过程

- 挂起线程1， 将线程在 CPU 的状态 （上下文）存储在内存
- 恢复线程2， 将内存中的上下文在 CPU寄存器 中恢复
- 跳转到程序计数器的指定位置，继续执行之后的代码

## 线程的六种状态

- New 新建
- Runnable 可运行
- Terminated 终止
- Blocked 被阻塞
- Waiting 无限等待
- Timed_Wating 超时等待
- 初始态 -> 运行态 -> 就绪 -> 终止态
- 线程获取锁失败 -> 阻塞态 -> 获取锁成功

## wait和sleep的区别

- sleep 方法没有释放锁
- wait 方法释放了锁
- wait 方法被调用后，需要别的线程调用同一个对象的 notify 或 notifyAll
- sleep 方法执行完成后，线程会自动苏醒

## 线程安全问题

- 线程安全指的是，多线程同时运行同一行代码，运行结果和单线程执行结果一致，且变量预期值一样

## 引发线程安全问题

- 线程安全问题是由多个线程共享变量引起的
- 如果多个线程对共享变量只有读操作，没有写操作，这个操作是线程安全
- 如果多个线程同时执行读写操作，需要考虑线程同步，否则可能引发线程安全问题

## 如何解决线程安全问题？

- 同步机制 synchronized
- 内存屏障 volatile
- 原子类 CAS
- 锁 AQS
- 并发容器

## 并发三大特性

- 原子性：一个系列指令代码，要么全部执行，要么都不执行，执行过程不能被打断
- 有序性：程序代码按照先后顺序执行
- 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到被修改的值
- 指令重排会出现无序问题
- Java内存模型(JMM) 会出现不可见问题

## 指令重排

- 指令重排(Instruction Reordering)指的是编译器和处理器为了优化程序性能对指令序列进行重排序的一种技术
- 为了提高程序运行效率， 编译器和处理器对执行指令进行重排序优化
- Java编译器、运行时和处理器都会保证，在单线程下遵循 as-if-serial 语义
- 指令重排不会影响单个线程的执行，但是会影响到线程并发执行的正确性

## as-if-serial语义

- 不管编译器和处理器如何优化字节码和指令重排，单线程所执行的结果不能受影响

## CPU缓存

- CPU 执行速度和内存读取速度差距大，需要在 CPU 和 物理内存上新增高速缓存

## CPU和缓存一致性

- 在多核 CPU 中，每个核都有自己的缓存，同一个数据的缓存内容可能不一致
- 程序在运行过程中，会将运算所需要的数据从主内存复制一份到 CPU 的高速缓存中
- 当 CPU 进行计算时，可以直接从高速缓存中读写数据，运算结束后再将数据刷新到主内存

## Java内存模型（Java Memory Model）

- JMM 定义了共享内存系统中多线程应用读写操作的行为规范
- JMM 规范了对内存的读写操作，从而保证指令执行的正确性
- JMM 规范解决了 CPU 多级缓存、处理器优化、指令重排等导致的内存访问的问题
- Java 实现了 JMM 规范，才有了 synchronized， volatile， 锁
- JMM 定义了共享变量何时写入，何时对另一个线程可见
- Java 实现了 JMM 规范保证 Java 程序在各种平台下对内存的访问都能保证效果一致的机制和规范
- JMM 在 Java 中的实现屏蔽了各种硬件和操作系统的访问差异
- 线程之间的共享变量存储在主内存中
- 每个线程都有一个私有的本地内存， 本地内存存储共享变量的副本
- 本地内存是抽象概念涵盖：缓存，写缓冲区，寄存器等

## JMM中线程操作内存的基本规则

- 线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接操作主内存
- 不同线程之间无法直接访问其他线程本地内存中的变量，需要经过主内存传递

## 如何保证共享变量共享？

- 线程A把本地内存A的共享变量副本值更新到主内存
- 线程B到主内存读取最新的共享变量值
- JMM 通过控制主内存与每个线程的本地内存之间的交互，来保证内存的可见性

## 如何解决可见性问题

- 使用 JMM中的 synchronized， volatile
- 遵循 happens-before 规则：按需使用重排序和本地内存副本

## happens-before规则

- 在JMM中，使用happens-before规则来约束编译器的优化行为，允许编译期优化，但需要遵守一定的 happens-Before 规则
- 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 的关系
- 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作
- 锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁
- volatile 变量规则：对一个 volatile 修饰的变量的写，happens-before 于任意后续对这个 volatile 修饰的变量的读
- 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C

## happens-before规则的实现

- 处理器重排序规则
- 编译器重排序规则